# Paul Schrum    Unity ID: ptschrum
# Course Project for GIS 540
"""
Given one or more input files (required to be Polylines),
an output file, an optional LoadCheck boolean, and an optional
spatial reference, generate one or more csv files showing the
radius (and other attributes) of each point triplet in the
polylines.  Really the only function you need to call is
analyzePolylines.
It does all the work and all the other functions and classes
just serve analyzePolylines.
"""

__author__ = ['Paul Schrum']

print 'starting imports'
import sys
import os
from arcpy.arcobjects.arcobjects import Point as arcPoint
import arcpy
import collections
from ExtendedPoint import ExtendedPoint
from ExtendedPoint import any_in_point_equals_any_in_other
from ExtendedPoint import compute_arc_parameters
print 'finished imports'

def arcPrint(aString):
    print aString
    arcpy.AddMessage(aString)

successList = []


def analyzePolylines(fcs, outDir, loadCSVtoFeatureClass=False,spatialRef=None):
    """
    This is the only function you need to call.
    Given a list of Polyline Feature classes, compute the curve data for each
    curve (circular arc segment) that passes through each triplet of points.
    :param fcs: Name of feature class to be processed (or list of feature classes)
    :param outDir: Directory to put the resulting csv files. (CSV names are autogenerated)
    :param loadCSVtoFeatureClass: Optional. Load the csv file back into arcmap as a confidence check
    :param spatialRef: Coordinate System to which to project point coordinates and show length units
    :return: None
    """
    try:
        validate_or_create_outDir(outDir)
    except:
        arcPrint("Unable to create output directory. No files processed.")
        return

    if type(fcs) is str:
        fcs_list = [fcs]
    else:
        fcs_list = fcs

    for fc in fcs_list:
        try:
            arcPrint("Now processing {0}".format(fc))
            csvName = processFCforCogoAnalysis(fc, outDir, spatialRef=spatialRef)
            successList.extend(csvName)
            arcPrint("File created: {0}".format(csvName))
            arcPrint(" ")
        except NotPolylineError:
            arcPrint("{0} not processed because it " + \
                  "is not a Polyline Feature Class.".format(fc))
        except arcpy.ExecuteError:
            arcPrint("Arc Error while processing Feature Class: {0}".format(fc))
        except Exception as e:
            arcPrint("Unexpected error: {0}".format(e.message))
            raise

    if loadCSVtoFeatureClass and len(successList) > 0:
        tempPoints = 'tempPoints___'
        mxd = arcpy.mapping.MapDocument('CURRENT')
        dataFrame = mxd.activeDataFrame

        try:
            for csv in successList:
                baseName = os.path.basename(csv)[:-4] + "_check"
                newLayerName = arcpy.env.workspace + '/' + baseName
                arcpy.AddMessage('Workspace: {0}'.format(arcpy.env.workspace))
                arcpy.MakeXYEventLayer_management(csv, 'X', 'Y',
                                                  tempPoints,
                                                  spatial_reference=spatialRef)
                arcpy.AddMessage('Attempting to Add Layer: {0}'.format(baseName))
                arcpy.PointsToLine_management(tempPoints, newLayerName)
                layerObj = arcpy.mapping.Layer(newLayerName)
                arcpy.mapping.AddLayer(dataFrame, layerObj, 'BOTTOM')
                arcpy.AddMessage('Added Layer: {0}'.format(baseName))
        finally:
            arcpy.Delete_management(tempPoints)
            del mxd
    else:
        arcpy.AddMessage('Loading check layers was not requested.')
        arcpy.AddMessage(' ')


def processFCforCogoAnalysis(fc, outputDir, spatialRef=None):
    """
    Process a Polyline file to analyze its points, generating a csv file of
    the same name, but saved to the output Directory.
    :param fc: Feature Class to be processed.
    :param outputDir: Output directory to put the resulting csv file in.
    :return: list of filename(s) of the csv file that was saved (str)
    """
    confirmFCisPolyline(fc)
    returnList = []
    alignmentsList = getListOfAlignmentsAsPoints(fc, spatialRef=spatialRef)
    for num, alignment in enumerate(alignmentsList):
        outputFile = _generateOutputFileName(fc, num, outputDir)
        returnList.append(outputFile)
        processPointsForCogo(alignment)
        writeToCSV(alignment, outputFile)
    return returnList

def processPointsForCogo(listOfPoints):
    """
    For each triplet of points in the list of points, compute the
    attribute data for the arc (circular curve segment) that starts
    at point 1, passes through point 2, and ends at point 3.  Then
    assign the curve data to point 2 for safe keeping.
    :param listOfPoints: A list of points to be analyzed. These must be ordered spatially or the results are meaningless.
    :return: None
    """
    for pt1, pt2, pt3 in zip(listOfPoints[:-2],
                             listOfPoints[1:-1],
                             listOfPoints[2:]):
        compute_arc_parameters(pt1, pt2, pt3)


def writeToCSV(pointList, fileName):
    """
    Write all points in the point list to the indicated file, expecting
    the points to be of type ExtendedPoint.
    :param pointList:
    :return: None
    """
    with open(fileName, 'w') as f:
        headerStr = ExtendedPoint.header_list()
        f.write(headerStr + '\n')
        for i, point in enumerate(pointList):
            writeStr = str(point)
            f.write(writeStr + '\n')

def getListOfAlignmentsAsPoints(fc, spatialRef=None):
    """
    Given a feature class (believed to be Polyline), convert each
    contiguous line segment into an spatially ordered list of points.
    :param fc: Feature Class to extract points from
    :return: List of List of Points. Each List of Points represents a single
            alignment.
    :rtype: List of list of ExtendedPoints.
    """
    # Extract all of the segments into a list of segments.
    # Note: A key assumption is that points within a given segment are
    # already spatially ordered
    segmentList = _breakPolylinesIntoSegments(fc, spatialRef=spatialRef)
    # _writeToCSV(segmentList, 'segmentListDump.csv')

    alignmentList = []
    while len(segmentList) > 0:
        pointList = getPointListFromSegmentList(segmentList)
        alignmentList.append(pointList)

    return alignmentList


def getPointListFromSegmentList(segmentDeque):
    """
    Gets a point list (spatially ordered) from a Deque of Polyline Segments.
    (The Polyline Segments have already been reduced to just points.)
    As a Polyline Segment is added to the return list, it is removed from the
    segmentDeque.  If more than one alignment have been passed to this function,
    it will only remove the segments which are colinear with the first segment.
    Thus len(segmentDeque) will not == 0.
    :param segmentList: Deque containing all of the Polyline Segments
    :return: List of Points that are spatially ordered from beginning to end.
    """
    # Check for adjacency going to the right
    currentSegment = segmentDeque.popleft()
    orderedSegments = collections.deque()
    orderedSegments.append(currentSegment)
    firstSegment = currentSegment
    matchingSegment = True
    while matchingSegment: # Search right from firstSegment
        matchingSegment = False
        for i in xrange(len(segmentDeque)):
            matches = any_in_point_equals_any_in_other(currentSegment.endPoints,
                                                       segmentDeque[0].endPoints)
            if matches:
                testSegment = segmentDeque.popleft()
                if matches[0] == 0:  # if current's begin point is the match
                    currentSegment.reverse()
                if matches[1] == 1:  # if test's end point is the match
                    testSegment.reverse()
                testSegment.popleft() # eliminates duplicate point
                orderedSegments.append(testSegment)
                currentSegment = testSegment
                matchingSegment = True
                break
            segmentDeque.rotate(-1)  # for performance since deque is a linked list

    matchingSegment = True
    currentSegment = firstSegment
    while matchingSegment: # Search left from firstSegment
        matchingSegment = False
        for i in xrange(len(segmentDeque)):
            matches = any_in_point_equals_any_in_other(currentSegment.endPoints,
                                                       segmentDeque[0].endPoints)
            if matches:
                testSegment = segmentDeque.pop()
                if matches[0] == 1:  # if current's end point is the match
                    currentSegment.reverse()
                if matches[1] == 0:  # if test's begin point is the match
                    testSegment.reverse()
                testSegment.pop() # eliminates duplicate point
                orderedSegments.appendleft(testSegment)
                currentSegment = testSegment
                matchingSegment = True
                break
            segmentDeque.rotate(1)  # for performance since deque is a linked list

    # flatten all points to a single list
    # orderPoints = [pt for seg in orderedSegments for pt in seg]
    orderedPoints = []
    for seg in orderedSegments:
        for pt in seg:
            orderedPoints.append(pt)

    return orderedPoints


class _PolylineSegment(collections.deque):
    """
    Convenience class to make picking the start point and
    end point a little easier.
    """
    @property
    def endPoints(self):
        return self[0], self[-1]

def _breakPolylinesIntoSegments(fc, spatialRef=None):
    """
    Given a feature class (Polyline), returns all segments
    broken out as ExtendedPoints.
    :param fc: Feature Class to break into segments.
    :param onlySoSelected: If true, only operate on selected items
    :return: deque of all segments in the feature class
    :rtype: deque (of list of segments)
    """
    segmentDeque = collections.deque()
    oidName = arcpy.Describe(fc).OIDFieldName

    lines_cursor = arcpy.da.SearchCursor(fc, ["SHAPE@", oidName], spatial_reference=spatialRef)
    try:
        for lines_row in lines_cursor:
            oid = lines_row[1]
            aPolylineSegment = _PolylineSegment()
            geom = lines_row[0]
            for partIndex in range(geom.partCount):
                geomPart = geom.getPart(partIndex)
                for aPoint in geomPart:
                    aPolylineSegment.append(ExtendedPoint(aPoint, parentPK=oid))
            segmentDeque.append(aPolylineSegment)
    finally:
        del lines_cursor
    return segmentDeque

def _generateOutputFileName(seedName, fileNumber, outDir):
    """
    Takes a feature class name and generates a .csv filename from it
    with the outDir path (instead of the original path).
    :param seedName: Name of feature class to bass output file name on
    :param outDir: Directory to prepend to the seedName
    :rtype: str
    """
    seedName_ = seedName
    if seedName.endswith('.shp'):
        seedName_ = seedName[:-4]
    if fileNumber > 0:
        fn = str(fileNumber)
    else:
        fn = ""
    return outDir + '/' + os.path.basename(seedName_) + fn + '.csv'


class NotPolylineError(TypeError):
    """
    Indicates that the given file or feature class is not a Polyline type.
    """
    pass


def confirmFCisPolyline(fc):
    """
    If the parameter fc is an ArcGIS polyline, the function does nothing.
    If it is not a polyline, it raises NotPolylineError
    :param fc:
    :return: None
    :raises: NotPolylineError
    """
    desc = arcpy.Describe(fc)
    if not (desc.dataType == 'ShapeFile' or desc.dataType == 'FeatureClass'):
        raise NotPolylineError
    if desc.shapeType != 'Polyline':
        raise NotPolylineError

def validate_or_create_outDir(outDir):
    """
    If the output directory does not already exist, create it.
    :param outDir:
    :return:
    """
    if not os.path.exists(outDir):
        os.makedirs(outDir)

if __name__ == '__main__':
    """
    Code for testing outside of ArcMap.
    """
    if False:
        arcpy.env.workspace = r"C:\GISdata\SelectedRoads.gdb"
        featureClasses = [r'C:\GISdata\SelectedRoads.gdb\LeesvilleRoadRaleigh',
                          r'C:\GISdata\SelectedRoads.gdb\CatesAvenue',
                          r'C:\GISdata\SelectedRoads.gdb\DanAllenDrive',
                          r'C:\GISdata\SelectedRoads.gdb\FaucetteDrive',
                          r'C:\GISdata\SelectedRoads.gdb\MorrillDrive',
                          ]
        neuseRiver = [r"C:\SourceModules\CogoPy\data\other\Neuse401.shp"]
        outputDir = r"C:\GISdata\testOutput"

        analyzePolylines(neuseRiver,
        # analyzePolylines(featureClasses,
                         outputDir,
                         loadCSVtoFeatureClass=False,
                         spatialRef=None)
    else:
        arcpy.env.workspace = r"D:\NCSU\201703 Fall 2017\GIS 630 Independent Study\GIS\inputs"
        Y15A = r"D:\NCSU\201703 Fall 2017\GIS 630 Independent Study\GIS\inputs\Y15A.shp"
        outputDir = r"D:\NCSU\201703 Fall 2017\GIS 630 Independent Study\GIS\outputs"

        analyzePolylines(Y15A, outputDir, loadCSVtoFeatureClass=False, spatialRef=None)

